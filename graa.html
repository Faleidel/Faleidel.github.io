<html>
	<head>
		<!--
<script src="../jquery-2.0.3.min.js"></script>
-->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<meta charset="UTF-8"/>

		
		<style>
			a
{
	color : #FFF ;
	text-decoration : none ;
	text-shadow : 0px 0px 10px #55F , 0px 0px 10px #55F ;
	transition : text-shadow 1s ;
	-webkit-transition : text-shadow 1s ;
	-moz-transition : text-shadow 1s ;
}
.linkStyle
{
	color : #FFF ;
	text-decoration : none ;
	text-shadow : 0px 0px 10px #55f , 0px 0px 10px #55f ;
}

a:hover  {  text-shadow : 0px 0px 20px #55f , 0px 0px 20px #55f ;  }
a:before { content : "-" ; }
a:after { content : "-" ; }

.linkLess:before { content : ""; }
.linkLess:after { content : ""; }

.linkLess
{
	text-shadow : 0px 0px 6px #55f , 0px 0px 6px #55f ;
}

.linkSuper
{
	text-shadow : 0px 0px 20px #55f , 0px 0px 20px #55f ;
}
a.linkSuper:hover  {  text-shadow : 0px 0px 50px #55f , 0px 0px 50px #55f ;  }

/* http://meyerweb.com/eric/tools/css/reset/ 
  v2.0 | 20110126
   License: none (public domain)
*/

html, body, div, span, applet, object, iframe,
h1, h2, h3, h4, h5, h6, p, blockquote, pre,
a, abbr, acronym, address, big, cite, code,
del, dfn, em, img, ins, kbd, q, s, samp,
small, strike, strong, sub, sup, tt, var,
b, u, i, center,
dl, dt, dd, ol, ul, li,
fieldset, form, label, legend,
table, caption, tbody, tfoot, thead, tr, th, td,
article, aside, canvas, details, embed, 
figure, figcaption, footer, header, hgroup, 
menu, nav, output, ruby, section, summary,
time, mark, audio, video {
	margin: 0;
	padding: 0;
	border: 0;
	font-size: 100%;
	font: inherit;
	vertical-align: baseline;
}
/* HTML5 display-role reset for older browsers */
article, aside, details, figcaption, figure, 
footer, header, hgroup, menu, nav, section {
	display: block;
}
body {
	line-height: 1;
}
ol, ul {
	list-style: none;
}
blockquote, q {
	quotes: none;
}
blockquote:before, blockquote:after,
q:before, q:after {
	content: '';
	content: none;
}
table {
	border-collapse: collapse;
	border-spacing: 0;
}

body h1.raphael
{
	font-size : 50px ;
	font-weight : 800 ;
	margin-bottom : 50px ;
	
	text-align : center ;
}

p.raphael
{
	margin-bottom : 30px ;
	text-align : center ;
	
	font-size : 20px ;
}

.templateDiv , .templateDivM , .templateDivE
{
/*	box-shadow : 0px 0px 10px #bbb ;*/
	padding : 40px ;
	width : 900px ;
	margin : auto ;
	
	background: -moz-linear-gradient(left,  rgba(0,0,0,0.3) 0%, rgba(0,0,0,0) 33%, rgba(0,0,0,0.7) 100%);
	background: -webkit-gradient(linear, left top, right top, color-stop(0%,rgba(0,0,0,0.3)), color-stop(33%,rgba(0,0,0,0.3)), color-stop(100%,rgba(0,0,0,0.7)));
	background: -webkit-linear-gradient(left,  rgba(0,0,0,0.3) 0%,rgba(0,0,0,0.3) 33%,rgba(0,0,0,0.7) 100%);
	background: -o-linear-gradient(left,  rgba(0,0,0,0.3) 0%,rgba(0,0,0,0.3) 33%,rgba(0,0,0,0.7) 100%);
	background: -ms-linear-gradient(left,  rgba(0,0,0,0.3) 0%,rgba(0,0,0,0.3) 33%,rgba(0,0,0,0.7) 100%);
	background: linear-gradient(to right,  rgba(0,0,0,0.3) 0%,rgba(0,0,0,0.3) 33%,rgba(0,0,0,0.7) 100%);
	filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#00000000', endColorstr='#80000000',GradientType=1 );
	
	border-top-right-radius : 12px ;
	
	border : solid 4px #bbb ;
}

.templateDiv
{
	margin-top : 80px ;
	border-bottom : 0px ;
}

.templateDivM
{
	border-top-right-radius : 0px ;
	border-bottom-right-radius : 0px ;
	border-top : 0px ;
	border-bottom : 0px ;
}

.templateDivE
{
	border-top-right-radius : 0px ;
	border-bottom-right-radius : 12px ;
	border-top : 0px ;
}

.templateDiv2 , .templateDiv3 , .templateDiv4
{
	width : 600px ;
	height : 60px ;
	margin : auto ;
	
	border-bottom-right-radius : 12px ;
	
	border : solid 4px #bbb ;
	border-top : 0px ;
	
	box-shadow : 0px 0px 10px #bbb ;
	
	background: -moz-linear-gradient(left,  rgba(0,0,0,0) 0%, rgba(0,0,0,0.45) 100%);
	background: -webkit-gradient(linear, left top, right top, color-stop(0%,rgba(0,0,0,0)), color-stop(100%,rgba(0,0,0,0.45)));
	background: -webkit-linear-gradient(left,  rgba(0,0,0,0) 0%,rgba(0,0,0,0.45) 100%);
	background: -o-linear-gradient(left,  rgba(0,0,0,0) 0%,rgba(0,0,0,0.45) 100%);
	background: -ms-linear-gradient(left,  rgba(0,0,0,0) 0%,rgba(0,0,0,0.45) 100%);
	background: linear-gradient(to right,  rgba(0,0,0,0) 0%,rgba(0,0,0,0.45) 100%);
	
	
	margin-bottom : 10px ;
}

.templateDiv3 { width : 400px ; }
.templateDiv4 { width : 200px ; margin-bottom : 50px ; }

.background
{
	width : 100% ;
	height : 100% ;
	
	background-image : url("imgbg.png") ;
	
	position : fixed ;
	top : 0px ;
	
	z-index : -1000 ;
	
	opacity : 0.7 ;
}

.backgroundW
{
	height : 0px ;
	width : 0px ;
	
	position : fixed ;
	
	top : 0px ;
	
	z-index : -1000 ;
	
	opacity : 0.7 ;
}

body
{
	background-color : #444 ;
}


			
			
			
			.hexagonSubTitle
			{
				text-align : center ;
				font-size : 45px ;
				margin-top : 80px ;
			}
		</style>
		
		<script>
			scrollEvents = [];

onscroll = function(e)
{
	for ( var i = 0 ; i < scrollEvents.length ; i++ )
	{
		if ( scrollEvents[i](e) )
		{
			scrollEvents.splice(i,1);
			i -= 1;
		}
	}
}













			/*
				Code by : RaphaÃ«l Mongeau
			*/
			
			$( function(){ init(); } );
			
			function init()
			{
				onkeydown = function(e){ keyDown(e) };
				onkeyup = function(e){ keyUp(e) };
				
				width = innerWidth-15; //hey, wtf...
				height = innerHeight;
				
//				width = 200;
//				height = 200;
				
				//canvas
				document.getElementById("canvasDiv").innerHTML = "<canvas id='myCanvas' width='" + width + "' height='" + height + "'></canvas>";
				window.canvas = document.getElementById('myCanvas');
				window.ctx = canvas.getContext('2d');
				//c-
				
				window.camX = 0;
				window.camY = 0;
				
				xc = width/2;
				yc = height/2;
				
				keys = {};
				lastKeys = {};
				keysClic = {};
				
				//vars
				time = 0;
				
				blood = [];
				
				//shaders
//				vertexShader = sinVertexShader;
				
				//start();
				
				titles = []
				
				p1 = createPlayer(1);
				p2 = createPlayer(2);
				
				fightState = 0;
				fightStateTimer = 0;
				
				setState( update );
			}
			
			function start()
			{
				playing = setInterval(function(){  update();  },1000/60);
			}
			
			function setState( stateFunction )
			{
				playing = setInterval( stateFunction , 1000/60 );
			}
			
			function stopState()
			{
				clearInterval( playing );
			}
			
			function changeState( stateFunction )
			{
				stopState();
				setState( stateFunction );
			}
			
			function updateEntitysIn( entitys )
			{
				for ( var i = 0 ; i < entitys.length ; i ++ )
					if ( entitys[i].update() )
					{
						entitys.splice( i , 1 );
						i -= 1;
					}
			}
			
			function drawEntitys( entitys )
			{
				for ( var i = 0 ; i < entitys.length ; i++ )
					entitys[i].draw();
			}
			
			//############################################  game main loop
			//############################################  game main loop
			//############################################  game main loop
			//############################################  game main loop
			function update()
			{
				time += 1;
				
				clearCanvas();
				
				//update
				updateKeys();
				
				updateEntitysIn( blood );
				
				p1.update();
				p2.update();
				
				if ( p1.state == 1 && p2.state == 1 && p1.shield && p2.shield && Math.abs(p1.x-p2.x) < 90 )
				{
					p1.velX += 10;
					p2.velX -= 10;
				}
				
				//draw
				startDraw();
				
				drawBackground();
				
				if ( p1.state == 1 )
					ctx.scale( sinTween(time,1,320)*0.4+1 , sinTween(time,1,320)*0.4+1 );
				else
					ctx.scale( sinTween(time,1,60)*0.2+1 , sinTween(time,1,60)*0.2+1 );
				
				
				if ( p1.state != 1 )
				{
					ctx.scale( 2.6 , 2.6 );
					ctx.translate( 0 , -60 );
				}
				
				p1.draw();
				p2.draw();
				
				fightStateTimer -= 1;
				
				if ( fightState == 1 && fightStateTimer < 0 )
				{
					fightState = 0;
					p1.state = 1;
					p2.state = 1;
					p1.x = 500;
					p2.x = -500;
				}
				
				drawEntitys( blood );
				
				if ( titles != null )
					drawTitles();
				
				if ( p1.life < 0 || p2.life < 0 )
					changeState( winState );
				
				endDraw();
			}
			
			function winState()
			{
				
			}
			
			function drawBackground()
			{
				drawPolygon( sinTween(time , 2000 , 500) - 1000 , sinTween( time , 200 , 250 ) , 0 , 200 , 30 , 'yellow' );
				drawRect( -1000 , -500 , 2000 , 400 , c( sinTween( time*1.2 , 255 , 100 ) , 50 , 50 ) );
				drawRect( -1000 , -200 , 2000 , 200 , c( sinTween( time , 255 , 100 ) , 50 , 50 ) );
			}
			
			function drawTitles()
			{
				if ( titles.length < 20 )
					if ( time % 50 == 0 )
						titles.push( createTitle() );
				
				if ( titles != null )
					drawEntitys( titles );
			}
			
			function startDraw()
			{
				ctx.save();
				ctx.translate( xc , yc );
				ctx.scale( 1 , -1 );
			}
			function endDraw()
			{
				ctx.restore();
			}
			
			//############################################# TITLE
			//############################################# TITLE
			//############################################# TITLE
			//############################################# TITLE
			function createTitle()
			{
				var t = {};
				
				var title = Math.floor( Math.random()*6 );
				if ( title == 0 )
					t.text = "TITLE";
				else if ( title == 1 )
					t.text = "WOW";
				else if ( title == 2 )
					t.text = "SUPER";
				else if ( title == 3 )
					t.text = "COMBAT";
				else if ( title == 4 )
					t.text = "FIGHT";
				else if ( title == 5 )
					t.text = "DOGE";
				
				t.x = Math.random()*100 - 50;
				t.y = Math.random()*100 - 50;
				
				t.draw = function()
				{
					ctx.save();
						ctx.scale( 10 , -10 );
						ctx.fillStyle = c( sinTween( time , 255 , 100 ) , 100 , 20 );
						ctx.fillText( t.text , t.x , t.y );
					ctx.restore();
				};
				
				return t;
			}
			
			//############################################# PLAYER
			//############################################# PLAYER
			//############################################# PLAYER
			//############################################# PLAYER
			function createPlayer( team )
			{
				var p = {};
				
				p.x = 0;
				p.y = 0;
				
				p.team = team;
				
				p.update = function(){ return updatePlayer(p) };
				p.draw = function(){ return drawPlayer(p) };
				
				p.state = 1;
				
				p.hiper = false;
				
				p.mouthPower = 1;
				p.headPower = 10;
				
				p.a1 = 180;
				p.a2 = 0;
				p.a3 = 0;
				
				p.legState = 0;
				
				p.velX = 0;
				p.velY = 0;
				
				p.shield = false;
				
				p.life = 50;
				
				if ( team == 1 )
					p.x = 200;
				else
					p.x = -200;
				
				return p;
			}
			function updatePlayer( p )
			{
				inputPlayer( p );
				
				p.legState -= 5;
				if ( p.legState < 0 ) p.legState = 0;
				if ( p.legState > 50 ) p.legState = 50;
				
				p.x += p.velX;
				p.y += p.velY;
				
				p.velX *= 0.9;
				p.velY *= 0.9;
				
				if ( p.state == 1 )
				{
					if ( p.shield )
					{
						p.a1 = 10;
						p.a2 = 160;
						p.a3 = 0;
					}
					else
					{
						p.a1 = 80 + sinTween( time , 20 , 100 );
						p.a2 = 0;
						p.a3 = 0;
					}
					
					p.mouthPower = 1;
					p.headPower = 10;
					p.hiper = false;
				}
				else if ( p.state == 2 ) //power
				{
					p.mouthPower = 10;
					p.headPower = 10;
					p.hiper = true;
					
					p.x = p.team==1?   70 : -70;
					
					p.a1 = time*30;
					p.a2 = 0;
					p.a3 = 0;
				}
				else if ( p.state == 3 ) //victim
				{
					p.mouthPower = 10;
					p.headPower = 10;
					p.hiper = true;
					
					p.x = p.team==1?   70 : -70;
					
					p.a1 = 10;
					p.a2 = 180 - p.blockPower;
					p.a3 = 0;
					
					p.blockPower -= 2;
					if ( p.blockPower < 0 ) p.blockPower = 0;
				}
				
				if ( p.team == 2 )
				{
					p.a1 *= -1;
					p.a2 *= -1;
					p.a3 *= -1;
				}
				
				if ( p1.x > 500 )
					p.velX -= 10;
				if ( p.x < -500 )
					p.velX += 10;
				
				return true;
			}
			function inputPlayer ( p )
			{
				p.shield = false;
				
				if ( p.state == 1 )
				{
					if ( p.team == 1 )
					{
						if ( keys['37'] )
						{
							p.x -= 2;
							p.legState += 10;
						}
						if ( keys['39'] )
						{
							p.x += 2;
							p.legState += 10;
						}
						if ( keysClic['38'] )
						{
							p.x -= 110;
							attack(p);
						}
						
						if ( keys['40'] )
							p.shield = true;
						
					}
					else
					{
						if ( keys['65'] )
						{
							p.x -= 2;
							p.legState += 10;
						}
						if ( keys['68'] )
						{
							p.x += 2;
							p.legState += 10;
						}
						if ( keysClic['87'] )
						{
							p.x += 110;
							attack(p);
						}
						
						if ( keys['83'] )
							p.shield = true;
					}
				}
				else if ( p.state == 2 )
				{
					var ap = p.team==1? p2 : p1;
					
					if ( p.team == 1 )
					{
						if ( keys['38'] )
						{
							ap.blockPower -= 3;
							if ( ap.blockPower < 5 )
							{
								ap.life -= 1;
								for ( var i = 0 ; i < 10 ; i++ )
									blood.push( createBlood( -80 , 80 ) );
							}
						}
					}
					else
					{
						if ( keys['87'] )
						{
							ap.blockPower -= 3;
							if ( ap.blockPower < 5 )
							{
								ap.life -= 1;
								for ( var i = 0 ; i < 10 ; i++ )
									blood.push( createBlood( 80 , 80 ) );
							}
						}
					}
				}
				else if ( p.state == 3 )
				{
					if ( p.team == 1 )
					{
						if ( keysClic['40'] )
							p.blockPower += 20;
					}
					else
					{
						if ( keysClic['83'] )
							p.blockPower += 20;
					}
				}
			}
			function attack( p )
			{
				var ap = p.team==1?p2:p1;
				
				if ( ap.shield )
				{
					if ( Math.abs( p.x - ap.x ) < 150 )
						p.velX += p.team==1? 20 : -20 ;
					
					return;
				}
				
				if ( Math.abs( p.x - ap.x ) < 150 )
				{
					ap.state = 3;
					ap.blockPower = 10;
					p.state = 2;
					fightState = 1;
					fightStateTimer = 100;
				}
			}
			function drawPlayer( p )
			{
				ctx.save();
					ctx.translate( p.x , p.y );
					
					//body
					drawRect( 0 , 30 , 30 , 70 , 'red' );
					
					//right leg
					
					ctx.save();
						ctx.rotate( a( Math.random()*4-2 )*(p.legState/10) );
						drawRect( 20 , -65 , 15 , 90 , 'red' );
					ctx.restore();
					
					//left leg
					ctx.save();
						ctx.rotate( a( Math.random()*4-2 )*(p.legState/10) );
						drawRect( -5 , -65 , 15 , 90 , 'red' );
					ctx.restore();
					
					//head
					ctx.save();
						if ( p.hiper )
							ctx.rotate( a( Math.random()*p.headPower-(p.headPower/2) ) );
						drawRect( -5 , 105 , 40 , 40 , 'red' );
						ctx.save();
							var ms = 1;
							if ( p.hiper ) ms += sinTween( time , 1.3 , 10 );
							ctx.rotate( a( Math.random()*p.mouthPower-(p.mouthPower/2) ) );
							drawRect( 2 + (-20*(ms-1)/2) , 110 , 20 * ms , 10 * ms , 'white' );
						ctx.restore();
						
						if ( p.state == 2 )
						{
							drawRect( 2 , 130 , 5 , 5 , "white" );
							drawRect( 19 , 130 , 5 , 5 , "white" );
						}
					ctx.restore();
					
					//arm
					ctx.save();
						if ( p.team == 1 )
							ctx.translate( -50 , 0 );
						ctx.translate( 45 , 95 );
						ctx.rotate( a( p.a1 ) );
						drawRect( 0 , 0 , 10 , 30 , "red" );
						ctx.translate( 0 , 30 );
						ctx.rotate( a( p.a2 ) );
						drawRect( 0 , 0 , 10 , 30 , "green" );
						
						ctx.translate( 0 , 30 );
						ctx.rotate( a( p.a3 ) );
						drawRect( 0 , 0 , 5 , 60 , "blue" );
					ctx.restore();
				ctx.restore();
			}
			
			
			//############################################# BLOOD
			//############################################# BLOOD
			//############################################# BLOOD
			//############################################# BLOOD
			function createBlood( x , y )
			{
				var b = {};
				
				b.x = x;
				b.y = y;
				
				var angle = Math.random()*360;
				b.velX = trustX( angle , 10 );
				b.velY = trustY( angle , 10 );
				
				b.update = function(){ return updateBlood(b); };
				b.draw = function(){ drawBlood(b); };
				
				return b;
			}
			function drawBlood( b )
			{
				drawRect( b.x , b.y , 10 , 10 , "red" );
			}
			function updateBlood( b )
			{
				b.x += b.velX;
				b.y += b.velY;
				
				b.velX *= 0.96;
				b.velY -= 0.1;
				
				return b.y < -200;
			}
			
			//############################################# DRAW FUNCTIONS
			//############################################# DRAW FUNCTIONS
			//############################################# DRAW FUNCTIONS
			//############################################# DRAW FUNCTIONS
			function clearCanvas( color )
			{
				ctx.save();
				if ( color )
					ctx.fillStyle = color;
				else
					ctx.fillStyle = '000000';
				ctx.globalAlpha = 0.1;
				ctx.fillRect(0,0,canvas.width,canvas.height);
				ctx.globalAlpha = 1;
				ctx.restore();
	    		}
			
			//clip
			function clip( x , y , width , height )
			{
				ctx.rect(0,0,width,height);
				ctx.stroke();
				ctx.clip();
			}
			
			function unClip()
			{
				clip( 0, 0 , width , height );
			}
			
			// DRAW FUNCTIONS
			function drawPolygon( x , y , angle , size , faceNum , color )
			{
				ctx.save();
				
//				ctx.translate( x , y );
				ctx.rotate( angle*(Math.PI/180) );
				
				ctx.strokeStyle = color;
				ctx.fillStyle = color;
				ctx.beginPath();
				ctx.lineWidth = 1;
				
				for ( var i = 0 ; i < faceNum ; i++ )
				{
					lineTo( trustX( i*(360/faceNum) , size ) + x , trustY( i*(360/faceNum) , size ) + y );
				}
				
				ctx.fill();
				ctx.closePath();
				
				ctx.restore();
	    		}
			
			// DRAW FUNCTIONS
			function drawPolygonRumble( x , y , angle , size , faceNum , color )
			{
				ctx.save();
				
				ctx.translate( x , y );
				ctx.rotate( angle*(Math.PI/180) );
				
				ctx.strokeStyle = color;
				ctx.fillStyle = color;
				ctx.beginPath();
				ctx.lineWidth = 1;
				
				for ( var i = 0 ; i < faceNum ; i++ )
					lineTo( trustX( i*(360/faceNum) , size + sinTween( time*1.2 , 10 , 100 ) ) , trustY( i*(360/faceNum) , size + sinTween( time*1.1 , 10 , 100 ) ) );
				
				ctx.closePath();
				ctx.fill();
				
				ctx.restore();
	    		}
			
			// DRAW FUNCTIONS
			function drawPolyPart( x , y , angleStart , angleEnd , width , height , color )
			{
				var div = 1;
				var aw = Math.abs(angleStart-angleEnd)/div;
				
				for ( var i = 1 ; i < div+1 ; i++ )
					drawPolyPart1( x , y , angleStart , angleStart+(aw*i) , width , height , color );
			}
			
			// DRAW FUNCTIONS
			function drawPolyPart1( x , y , angleStart , angleEnd , width , height , color )
			{
				ctx.save();
				
				ctx.translate( x , y );
				
				ctx.strokeStyle = color;
				ctx.fillStyle = color;
				ctx.beginPath();
				ctx.lineWidth = 1;
				
				moveTo(   trustX( angleStart , height       )   ,   trustY( angleStart , height       )   );
				lineTo(   trustX( angleEnd   , height       )   ,   trustY( angleEnd   , height       )   );
				lineTo(   trustX( angleEnd   , height+width )   ,   trustY( angleEnd   , height+width )   );
				lineTo(   trustX( angleStart , height+width )   ,   trustY( angleStart , height+width )   );
				lineTo(   trustX( angleStart , height       )   ,   trustY( angleStart , height       )   );
				
				ctx.closePath();
				ctx.fill();
				
				ctx.restore();
			}
			
			// DRAW FUNCTIONS
			function drawTriangle( x , y , angle , size , color )
			{
				ctx.save();
				
				ctx.strokeStyle = color;
				ctx.fillStyle = color;
				ctx.beginPath();
				ctx.lineWidth = 1;
				
				size/=3;
				
				var p1 = rotatePoint( trustX(0,size) , trustY(0,size) , angle );
				moveTo( p1.x + x , p1.y + y );
				p1 = rotatePoint( trustX(360/3,size) , trustY(360/3,size) , angle );
				lineTo( p1.x + x , p1.y + y );
				p1 = rotatePoint( trustX(360/3*2,size) , trustY(360/3*2,size) , angle );
				lineTo( p1.x + x , p1.y + y );
				
				ctx.closePath();
				ctx.fill();
				
				ctx.restore();
			}
			
			// DRAW FUNCTIONS
			function drawTriangleAtHeight( x , y , angle , size , color , height )
			{
				drawTriangle( x + trustX( angle , height ) , y + trustY( angle , height ) , angle , size , color );
			}
			
			// DRAW FUNCTION
			function drawCircle( x , y , r , color )
			{
				ctx.save();
				
				ctx.translate( x , y );
				
				ctx.beginPath();
				ctx.arc( 0 , 0 , r , 0 , 2 * Math.PI , false);
				ctx.fillStyle = color;
				ctx.fill();
				
				ctx.restore();
			}
			
			// DRAW FUNCTIONS
			function drawRect( x , y , width , height , color )
			{
				ctx.save();
				ctx.fillStyle = color;
				ctx.fillRect( x-camX , y-camY , width , height );
				ctx.restore();
			}
			
			////////////////////////////////  SHADERS
			//redo ctx draw functions with shaders
			function moveTo( X , Y )
			{
				var pos = vertexShader( X , Y );
				ctx.moveTo( pos.x , pos.y );
			}
			
			function lineTo( X , Y )
			{
				var pos = vertexShader( X , Y );
				ctx.lineTo( pos.x , pos.y );
			}
			
			//   vertex
			function vertexShader( X , Y )
			{
				return { x : X , y : Y };
			}
			
			function baseVertexShader( X , Y )
			{
				return { x : X , y : Y };
			}
			
			function sinVertexShader( X , Y )
			{
				var angle = getAngle( 0 , 0 , X , Y );
				var power = Math.sqrt( dist2( 0 , 0 , X , Y ) );
				
				var am = ((power*power)/4000)
				
				am /= 70;
				
//				angle += ( Math.sin(am)*100 ) * (sinTween( time , 1 , 100 ) * sinTween( time*1.1 , 0.5 , 20 ) * sinTween( time*1.2 , 1 , 200 ) * sinTween( time*1.3 , 1 , 100 ) );
				power += Math.sin( angle )*3;
				angle += Math.sin(power/30)*2;
				
				X = trustX( angle , power );
				Y = trustY( angle , power );
				
//				X += Math.sin(X/40)*20;
//				Y += Math.sin(Y/40)*20;
				
//				return { x : X , y : Y };
				return { x : (X+(Math.sin(X/20)*10)) , y : (Y+(Math.sin(Y/20)*10)) };
			}
			
			//---------------------UTILS
			//---------------------UTILS
			//---------------------UTILS
			//---------------------UTILS
			//---------------------UTILS
			//---------------------UTILS
			//---------------------UTILS
			//---------------------UTILS
			function sinTween( time , max , width )
			{
				return (Math.sin( (time*(Math.PI*2))/width )+1)/2 * max;
			}
			
			function getAngle( tx , ty , mx , my  )
			{
				var deltaX = mx - tx;
				var deltaY = my - ty;
				return (Math.atan2( deltaY , deltaX ))/Math.PI*180;
			}
			
			function angleDif( a1 , a2 )
			{
				a1 = clipAngle( a1 );
				a2 = clipAngle( a2 );
				
				var r = a2 - a1;
				
				if ( r > 180 )
					r = -(380-r);
				else if ( r < -180 )
					r = -(-360-r);
				
				return r;
			}
			
			function possibleRevert( chance , num )
			{
				if ( Math.random() < chance )
					return num * -1;
				else
					return num;
			}
			
			function clipAngle( angle )
			{
				while ( angle > 360 )
					angle -= 360;
				
				while ( angle < 0 )
					angle += 360;
				
				return angle;
			}
			
			function keyDown(e)
			{
				var evt = e || event.keyCode;
				var press = evt.which || event.keyCode;
				
				keys[ press+"" ] = true;
				
				if ( press == 37 || press == 38 || press == 39 || press == 40 || press == 32 )
				{
					e.preventDefault();
					return false;
				}
			}
			
			function keyUp(e)
			{
				var evt = e || event.keyCode;
				var press = evt.which || event.keyCode;
				
//				console.log(press);
				
				keys[ press+"" ] = false;
				
				if ( press == 37 || press == 38 || press == 39 || press == 40 || press == 32 )
				{
					e.preventDefault();
					return false;
				}
			}
			
			function trustX( angle , power )
			{
				return Math.cos(angle * (Math.PI / 180)) * power;
			}
			
			function trustY( angle , power )
			{
				return Math.sin((angle * (Math.PI / 180))) * power;
			}
			
			function a( angle )
			{
				return angle*(Math.PI/180);
			}
			
			function limit( x , l1 , l2 )
			{
				if ( x < l1 ) x = l1;
				if ( x > l2 ) x = l2;
				return x;
			}
			
			function addObjects( original , toAdd )
			{
				for ( var k in toAdd )
					original[k] = toAdd[k];
				return original;
			}
			
			function randomBetween( min , max )
			{
				return (Math.random()*(max-min))+min;
			}
			
			function randomNeg( range )
			{
				return Math.random()*range - range/2;
			}
			
			function makeBetween( value , min , max , toMax )
			{
				return (value-min)/(max-min)*toMax;
			}
			
			function c( r , g , b )
			{
				return "rgb(" + Math.floor(r) + "," + Math.floor(g) + "," + Math.floor(b) +  ")";
			}
			
			function addRandom( x , step , chances )
			{
				if ( Math.random() < chances )
					return addRandom( x+step , step , chances );
				else
					return x+step;
			}
			
			function dist2( x , y , x2 , y2 )
			{
				return Math.pow(x-x2,2)+Math.pow(y-y2,2);
			}
			
			function reflectAngle( angle , axe )
			{
				return ( -1*(angle-axe) )+axe;
			}
			
			function rotatePoint( x , y , rotation )
			{
				var angle = getAngle( 0 , 0 , x , y );
				var power = dist2( 0 , 0 , x , y );
				
				angle += rotation;
				
				return { x : (trustX(angle,power)) , y : (trustY(angle,power)) };
			}
			
			function updateKeys()
			{
				for ( var k in keys )
				{
					keysClic[k] = !keys[k] && lastKeys[k];
					lastKeys[k] = keys[k];
				}
			}












		</script>
	</head>
	
	<body style="background-color : #EEE ;">
		



<div class="backgroundW">
	<div class="background"></div>
</div>
<script>
	$( function(){
		$(".background").css( "height" , innerHeight+"px");
		$(".background").css( "width" , innerWidth+"px");
	} );
</script>

		
		
<div class="templateDiv">

			<div>
				

<h1 class="raphael">
	<a class="linkLess linkSuper" href="index.html">RaphaÃ«l Mongeau</a>
</h1>
<p class="linkStyle linkLess raphael">
	Programmeur | CrÃ©ateur de jeux | Artiste
</p>

				<div class="hexagonSubTitle linkStyle">
					Graaa (experiment)
				</div>
				<div class="hexagonSubTitle linkStyle" style="font-size:20px;">
					<div>This is a crazy experimental game I made some time ago.</div>
					<div>Its a 2 player fighting game.</div>
					<div>Each players can control is fighter with the arrow keys or wasd</div>
					<div>Up is to attack, down is to defend.</div>
					<div>The rest of the game is inexplicable.</div>
				</div>
			</div>
		</div>

		
		<div class="twilightBorder"></div>
		
		<div>
			<div id="canvasDiv" style="height : 100% ; width : 100% ;"></div>
		</div>
		
		<div class="templateDivE">

			<div style="width : 1px ; height : 100px ;"></div>
		</div>

		
		<div class="templateDiv2"></div>
<div class="templateDiv3"></div>
<div class="templateDiv4"></div>

	</body>
</html>
